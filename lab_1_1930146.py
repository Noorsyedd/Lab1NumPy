# -*- coding: utf-8 -*-
"""Lab_1_1930146.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vw0CCqrx5yGI4AXcgpvBgHY-n61ciSjR

##### **Problem 09:**
Download the image of Lena Forsen from the following link: [https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png](https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png). Then, do the following tasks:

*  Load the image to a numpy array.
*  Find the size of the image.
*  Find the minimum and maximum value of the image.
*  Find the mean and standard deviation of the image.
*  Plot the image using `plt.imshow()` or `display()`.
*  Resize the image to 50 x 50.
*  Convert the image to grayscale.
*  Plot the grayscale image using `plt.imshow()` or `display()`.
*  Save the grayscale image using `imsave()`.
*  Stack the columns of the image to form a vector of size 2500 x 1.
"""

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image, ImageOps
from numpy import asarray
import requests
from io import BytesIO

response = requests.get('https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png')
image = Image.open(BytesIO(response.content))
print("The image:")
#Plot the image using plt.imshow() or display()
display(image)

#Load the image to a numpy array
data = asarray(image)

#Find the size of the image
print("Size of the image:",image.size)

#Find the minimum and maximum value of the image
Min = np.amin(data)
print("Minimum Value:",Min)
Max = np.amax(data)
print("Maximum Value:",Max)

#Find the mean and standard deviation of the image
print("Mean of the image:",np.mean(data))
print("Standard Deviation of the image:",np.std(data))

#Resize the image to 50 x 50
res = image.resize((50,50))
print("Resized the image to 50 x 50:")
display(res)

#Convert the image to grayscale
grays = ImageOps.grayscale(image)

#Plot the grayscale image using plt.imshow() or display()
print("The grayscale image:")
display(grays)

#Save the grayscale image using imsave()
plt.imsave('grayscale.jpg',grays )

#Stack the columns of the image to form a vector of size 2500 x 1
image.resize((500,500)) 
print("Shape of the original image:",data.shape) #original image shape is (512, 512, 3).So I had to resize to make the exact 2500 elements to form the vector as required for the assignment
stack = np.resize(data,(1,2500))
print("After stacking coloumn, the shape is:",stack.shape) 
#print(stack)   <--you can check if its size is 1*2500 or not.Which means it's a 1D array as required for the assignment
#print(stack.size)

"""##### **Problem 10:**
Compute 2nd order Taylor approximation of $e^{2x}$ and $e^{3x}$, and $e^{5x}$ around $a = 0$ for $x \in [-1, 1]$ with interval 0.01. Then, determine which of the following is more accurate:
> 1. Calculating the Taylor approximation separately for each $e^{2x}$, $e^{3x}$ then multiplying them together.
> 2. Calculating the Taylor approximation for $e^{5x}$.

Use mean square error (MSE) to determine the accuracy. Also, plot the Taylor approximation for 1st and 2nd method and the original function in the same plot for visual comparison.
"""

import numpy as np
import matplotlib.pyplot as plt
x = np.arange(-1,1, 0.01)

#generalized function
def fexp1(a,n): 
  return (2**n)*np.exp(2*a)
def fexp2(a,n): 
  return (3**n)*np.exp(3*a)
def fexp3(a,n): 
  return (5**n)*np.exp(5*a)


#Taylor series for e^2x
def taylor1(x,a,n):
  sum=0
  for i in range(0,n+1):
    sum+=(fexp1(a,i)*pow(x-a,i))/np.math.factorial(i)
  return sum
#Taylor series for e^3x
def taylor2(x,a,n):
  sum=0
  for i in range(0,n):
    sum+=(fexp2(a,i)*pow(x-a,i))/np.math.factorial(i)
  return sum

#Taylor series for e^5x
def taylor3(x,a,n):
  sum=0
  for i in range(0,n):
    sum+=(fexp3(a,i)*pow(x-a,i))/np.math.factorial(i)
  return sum

fx1=np.exp(2*x)
fx2=np.exp(3*x)
fx3=np.exp(5*x)

#a is the point where derivative of function evaluated at  
#x is the x value and 
#n is the order of the differentiation
T1=taylor1(x,0,2)
T2=taylor2(x,0,2)
T3=taylor3(x,0,2)

#Calculating the Taylor approximation separately for each e^2x and e^3x,  then multiplying them together
T4 = T2*T3
fx4=fx1*fx2

#mean square error (MSE) function
def mse(actual, pred): 
    actual, pred = np.array(actual), np.array(pred)
    return np.square(np.subtract(actual,pred)).mean() 

#MSE for option-1 given in the question
Option1 = mse(fx4, T4)
print("Mean square error (MSE) for 1.Calculating the Taylor approximation separately for each e^2x and e^3x,  then multiplying them together is : ",Option1)
#MSE for option-2 given in the question
Option2 = mse(fx3, T3)
print("Mean square error (MSE) for 2.Calculating the Taylor approximation for e^5x is : ",Option2)
print("Answer: Option-2 is more accurate!") if Option1 > Option2 else print("Answer: Option-1 is more accurate!")

f = plt.figure()
f.set_figwidth(20)  #adjust plot width
f.set_figheight(16) #adjust plot length
plt.title("Taylor's Approximation 2nd Order of e^2x, e^3x and e^5x")
plt.plot(x,fx1,label="f(x)=e^2x",color='k' ,marker = "x")
plt.plot(x,fx2,label="g(x)=e^3x",color='orange',marker = "o"  )
plt.plot(x,fx3,label="h(x)=e^5x",color='red') 

plt.plot(x,T1,label="Taylor's Approximation 2nd Order of e^2x",color="c")
plt.plot(x,T2,label="Taylor's Approximation 2nd Order of e^3x",color="blue")
plt.plot(x,T3,label="Taylor's Approximation 2nd Order of e^5x",color="m")
plt.xlabel("x")
plt.ylabel("y=f(x)")
plt.legend()
plt.grid()
plt.show()

"""

Name: Syed Noor - A - Manik


ID: 1930146

Course Code: CSE 317L

Section:2

Semester: Autumn 2022
"""